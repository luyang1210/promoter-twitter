% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap_MRF.R
\name{bootstrap_MRF}
\alias{bootstrap_MRF}
\title{Bootstrap observations to estimate MRF parameter coefficients}
\usage{
bootstrap_MRF(data, n_bootstraps, n_its, sample_seed, min_lambda1, max_lambda1,
  by_lambda1, symmetrise, n_nodes, n_cores, n_covariates, family, fixed_lambda)
}
\arguments{
\item{data}{Dataframe. The input data where the \code{n_nodes}
left-most variables are variables that are to be represented by nodes in the graph.
Note that \code{NA}'s are allowed for covariates. If present, these missing values
will be imputed from the distribution \code{rnorm(mean = 0, sd = 1)}, which assumes that
all covariates are scaled and centred (i.e. by using the function
\code{\link[base]{scale}} or similar)}

\item{n_bootstraps}{Positive integer. Represents the total number of bootstrap samples
to test in each of \code{n_its} or \code{seq(min_lambda1, max_lambda1, by_lambda1)} iterations.
Default is \code{10}.}

\item{n_its}{Positive integer. The number of iterations to perform \code{n_bootstraps} replicates
across. The use of two parameters provides more control for optimising parallel computations. It is
generally recommended to use a higher number for \code{n_its} relative to \code{n_bootstraps}, as
the job will be split across cores based on the \code{n_its} parameter.
If \code{fixed_lambda = TRUE}, this value is ignored and \code{n_its} is taken from the length of
\code{lambda1_seq = seq(min_lambda1, max_lambda1, by_lambda1)}. Default when \code{fixed_lambda = FALSE}
is \code{10}. This coincides with the default \code{n_bootstraps} of \code{10} to produce
\code{100} bootstrap replicates in total.}

\item{sample_seed}{Numeric. Used as the seed value for generating bootstrap replicates, allowing
users to generate replicated datasets on different systems. Default is a random seed}

\item{min_lambda1}{Positive numeric. The lowest l1 regularization value to be tested.
If \code{fixed_lambda = FALSE}, this value is ignored and penalization parameters are optimized automatially}

\item{max_lambda1}{Positive numeric. The highest l1 regularization to be tested.
If \code{fixed_lambda = FALSE}, this value is ignored and penalization parameters are optimized automatially}

\item{by_lambda1}{Positive numeric. The increment of the l1 test sequence. The test sequence is generated by calling
\code{lambda1_seq = seq(min_lambda1, max_lambda1, by_lambda1)}.
If \code{fixed_lambda = FALSE}, this value is ignored and penalization parameters are optimized automatially.}

\item{symmetrise}{The method to use for symmetrising corresponding parameter estimates
(which are taken from separate regressions). Options are \code{min} (take the coefficient with the
smallest absolute value), \code{max} (take the coefficient with the largest absolute value)
or \code{mean} (take the mean of the two coefficients). Default is \code{mean}}

\item{n_nodes}{Positive integer. The index of the last column in \code{data}
which is represented by a node in the final graph. Columns with index
greater than \code{n_nodes} are taken as covariates. Default is the number of
columns in \code{data}, corresponding to no additional covariates}

\item{n_cores}{Integer. The number of cores to spread the job across using
\code{\link[parallel]{makePSOCKcluster}}. Default is 1 (no parallelisation)}

\item{n_covariates}{Positive integer. The number of covariates in \code{data},
before cross-multiplication. Default is \code{ncol(data) - n_nodes}}

\item{family}{The response type. Responses can be quantitative continuous (\code{family = "gaussian"}),
non-negative counts (\code{family = "poisson"}) or binomial 1s and 0s (\code{family = "binomial"})}

\item{fixed_lambda}{Logical. If \code{FALSE}, node-specific regressions are optimized using the
cross-validation procedure in \code{\link[glmnet]{cv.glmnet}} to find the \code{lambda1} value
that minimises mean cross-validated error. If \code{TRUE}, each regression is run
at a single \code{lambda1} value (the same \code{lambda1} value is used for each separate
regression). Default is \code{FALSE}, meaning that arguments to \code{min_lambda1}, \code{max_lambda1}
and \code{by_lambda1} are ignored}
}
\value{
A \code{list} containing:
\itemize{
  \item \code{lambda_results}: if \code{fixed_lambda = TRUE}, a \code{list} of length \code{lambda1_seq} containing:
  \itemize{
  \item \code{key_covariates}: dataframes of important covariates (i.e. those retained in
  at least 90 percent of bootstrap replicates) at each l1 value
  \item \code{raw_coefs}: the raw estimated coefficients at each l1 value
  \item \code{indirect_coefs}: estimated higher order interaction coefficients at each l1 value
  }
  \item \code{direct_coef_means}: \code{dataframe} containing mean coefficient values taken from all
  bootstrapped models across the iterations
  \item \code{direct_coef_upper90} and \code{direct_coef_lower90}: \code{dataframe}s
  containing coefficient 95 percent and 5 percent quantiles taken from all
  bootstrapped models across the iterations
  \item \code{indirect_coef_mean}: \code{list} of matrices containing mean higher order coefficient values
  taken from all bootstrapped models across the iterations
  \item \code{mean_key_coefs}: \code{list} of matrices of length \code{n_nodes}
  containing mean covariate coefficient values and their relative importances
  (using the formula \code{x^2 / sum (x^2)}
  taken from all bootstrapped models across iterations. Only coefficients
  with mean relative importances \code{>0.01} are returned. Note, relative importance are only
  useful if all covariates are on a similar scale.
  \item \code{mod_type}: A character stating the type of model that was fit
  (used in other functions)
  \item \code{mod_family}: A character stating the family of model that was fit
   (used in other functions)
   \item \code{poiss_sc_factors}: A vector of the square-root mean scaling factors
   used to standardise \code{poisson} variables (only returned if \code{family = "poisson"})
   }
}
\description{
This function runs \code{\link{MRFcov}} models multiple times using either a user-specified
range of l1 regularization values or cross-validation. To capture uncertainty
in paramter esimates, the dataset is shuffled and missing values are imputed
in each bootstrap iteration. Two parameters control the number of bootstrap iterations
to perform in order to facilitate optimal parallel computing.
}
\details{
\code{MRFcov} models are either run across the specified sequence of
\code{lambda1} values or \code{lambda1} is chosen through cross-validation using
\code{\link[glmnet]{cv.glmnet}}. For each model, the \code{data} is bootstrapped
by shuffling row observations and fitting models to only 90 percent of observations,
using \code{dplyr::sample_n(data, nrow(data) * 0.9, FALSE)},
to account for uncertainty in parameter estimates.
Parameter estimates from the set of bootstrapped models are summarised
to present means and confidence intervals.
}
\examples{
\dontrun{
data("Bird.parasites")

# Perform 100 bootstrap replicates in total
bootedCRF <- bootstrap_MRF(data = Bird.parasites,
                          n_nodes = 4,
                          family = 'binomial',
                          n_cores = 3)}
}
\seealso{
\code{\link{MRFcov}},
\code{\link[penalized]{penalized}},
\code{\link[glmnet]{cv.glmnet}}
}
