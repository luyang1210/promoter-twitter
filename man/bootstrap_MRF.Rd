% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap_MRF.R
\name{bootstrap_MRF}
\alias{bootstrap_MRF}
\title{Bootstrap observations to estimate MRF parameter coefficients}
\usage{
bootstrap_MRF(data, n_bootstraps, sample_seed, min_lambda1, max_lambda1,
  by_lambda1, lambda2, symmetrise, n_nodes, n_cores, n_covariates, fixed_lambda,
  family, n_its)
}
\arguments{
\item{data}{Dataframe. The input data where the \code{n_nodes}
left-most variables are variables that are to be represented by nodes in the graph.
Note that \code{NA}'s are allowed for covariates. If present, these missing values
will be imputed from the distribution \code{rnorm(mean = 0, sd = 1)}, which assumes that
all covariates are scaled and centred (i.e. by using the function
\code{\link[base]{scale}} or similar)}

\item{n_bootstraps}{Positive integer. Represents the total number of bootstrap samples
to test in each iteration. Default is 100.}

\item{sample_seed}{Numeric. Used as the seed value for generating bootstrap replicates, allowing
users to generate replicated datasets on different systems. Default is a random seed}

\item{min_lambda1}{Positive numeric. The lowest l1−regularization value to be tested.
If \code{fixed_lambda = FALSE}, this value is ignored and penalization parameters are optimized automatially}

\item{max_lambda1}{Positive numeric. The highest l1−regularization to be tested.
If \code{fixed_lambda = FALSE}, this value is ignored and penalization parameters are optimized automatially}

\item{by_lambda1}{Positive numeric. The increment of the l1 test sequence. The test sequence is generated by calling
\code{lambda1_seq = seq(min_lambda1, max_lambda1, by_lambda1)}.
If \code{fixed_lambda = FALSE}, this value is ignored and penalization parameters are optimized automatially.}

\item{lambda2}{Numeric (>= 0). Value for l2−regularization, where larger values lead
to stronger shrinking of coefficient magnitudes. Default is 0, but larger values
may be necessary for large or particularly sparse datasets}

\item{symmetrise}{The method to use for symmetrising corresponding parameter estimates
(which are taken from separate regressions). Options are \code{min} (take the coefficient with the
smallest absolute value), \code{max} (take the coefficient with the largest absolute value)
or \code{mean} (take the mean of the two coefficients). Default is \code{mean}}

\item{n_nodes}{Positive integer. The index of the last column in \code{data}
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in \code{data}, corresponding to no additional covariates}

\item{n_cores}{Integer. The number of cores to spread the job across using
\code{\link[parallel]{makePSOCKcluster}}. Default is 1 (no parallelisation)}

\item{n_covariates}{Positive integer. The number of covariates in \code{data},
before cross-multiplication. Default is \code{ncol(data) - n_nodes}}

\item{fixed_lambda}{Logical. If \code{FALSE}, node-specific regressions are optimized using the
cross-validation procedure in \code{\link[glmnet]{cv.glmnet}} to find the \code{lambda1} value
that minimises mean cross-validated error. If \code{TRUE}, each regression is run
at a single \code{lambda1} value (the same \code{lambda1} value is used for each separate
regression). Default is \code{FALSE}, meaning that arguments to \code{min_lambda1}, \code{max_lambda1}
and \code{by_lambda1} are ignored}

\item{family}{The response type. Responses can be quantitative continuous (\code{family = "gaussian"}),
non-negative counts (\code{family = "poisson"}) or binomial 1s and 0s (\code{family = "binomial"})}

\item{n_its}{Positive integer. The number of iterations to perform \code{n_bootstrap} replicates
across. If \code{fixed_lambda = TRUE}, this value is ignored and \code{n_its} is taken from the length of
\code{lambda1_seq = seq(min_lambda1, max_lambda1, by_lambda1)}. Default when \code{fixed_lambda = FALSE}
is \code{100}}
}
\value{
A \code{list} containing:
\itemize{
  \item \code{lambda_results}: if \code{fixed_lambda = TRUE}, a \code{list} of length \code{lambda1_seq} containing:
  \itemize{
  \item \code{key_covariates}: dataframes of important covariates (i.e. those retained in
  at least 90 percent of bootstrap replicates) at each l1 value
  \item \code{raw_coefs}: the raw estimated coefficients at each l1 value
  \item \code{indirect_coefs}: estimated higher order interaction coefficients at each l1 value
  }
  \item \code{direct_coef_means}: \code{dataframe} containing mean coefficient values taken from all
  bootstrapped models across the iterations
  \item \code{direct_coef_upper90} and \code{direct_coef_lower90}: \code{dataframe}s
  containing coefficient 95 percent and 5 percent quantiles taken from all
  bootstrapped models across the iterations
  \item \code{indirect_coef_mean}: \code{list} of matrices containing mean higher order coefficient values
  taken from all bootstrapped models across the iterations
  \item \code{mean_key_coefs}: \code{list} of matrices of length \code{n_nodes}
  containing mean covariate coefficient values and their relative importances
  (using the formula \code{x^2 / sum (x^2)}
  taken from all bootstrapped models across iterations. Only coefficients
  with mean relative importances \code{>0.01} are returned. Note, relative importance are only
  useful if all covariates are on a similar scale.
  \item \code{mod_type}: A character stating the type of model that was fit
  (used in other functions)
  \item \code{mod_family}: A character stating the family of model that was fit
   (used in other functions)
   \item \code{poiss_sc_factors}: A vector of the square-root mean scaling factors
   used to standardise \code{poisson} variables (only returned if \code{family = "poisson"})
   }
}
\description{
This function runs \code{\link{MRFcov}} models multiple times using either a user-specified
range of l1 regularization values or cross-validation. To capture uncertainty
in paramter esimates, the dataset is bootstrapped a user-specified number of times in each iteration.
}
\details{
\code{MRFcov} models are either run across the specified sequence of
\code{lambda1} values or \code{lambda1} is chosen through cross-validation using
\code{\link[glmnet]{cv.glmnet}}. For each model, the \code{data} is bootstrapped
by shuffling row observations, using \code{dplyr::sample_n(data, nrow(data), TRUE)},
to account for uncertainty in parameter estimates.
Parameter estimates from the set of bootstrapped models are summarised
to present confidence intervals.
}
\examples{
\dontrun{
data("Bird.parasites")
bootedCRF <- bootstrap_MRF(data = Bird.parasites,
                          n_nodes = 4, n_its = 10, n_bootstraps = 100,
                          family = 'binomial')}
}
\seealso{
\code{\link{MRFcov}},
\code{\link[penalized]{penalized}},
\code{\link[glmnet]{cv.glmnet}}
}
