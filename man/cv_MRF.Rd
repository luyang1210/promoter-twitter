% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv_MRF.R
\name{cv_MRF}
\alias{cv_MRF}
\title{MRF cross validation to optimise regularization parameters}
\usage{
cv_MRF(data, min_lambda1, max_lambda1, by_lambda1, lambda2, separate_min,
  n_nodes, n_cores, sample_seed, n_folds, n_fold_runs, n_covariates, family)
}
\arguments{
\item{data}{Dataframe. The input data where the \code{n_nodes}
left-most variables are binary occurrences to be represented by nodes in the graph.
Note that \code{NA}'s are allowed for covariates. If present, these missing values
will be imputed from the distribution \code{rnorm(mean = 0, sd = 1)}, which assumes that
all covariates are scaled and centred (i.e. by using the function
\code{\link[base]{scale}} or similar)}

\item{min_lambda1}{Positive numeric. The lowest l1−regularization value to be tested}

\item{max_lambda1}{Positive numeric. The highest l1−regularization value to be tested}

\item{by_lambda1}{Positive numeric. The increment of the l1 test_data sequence.
The test sequence is generated by calling \code{lamda1_seq = seq(min_lambda1, max_lambda1, by_lambda1)}}

\item{lambda2}{Numeric (>= 0). Value for l2−regularization, where larger values lead
to stronger shrinking of coefficient magnitudes. Default is 0, but larger values
may be necessary for large or particularly sparse datasets}

\item{separate_min}{Logical. If \code{TRUE}, interaction coefficients will use the minimum absolute value of
the corresponding parameter estimates, which are taken from separate logistic regressions,
in the symmetric postprocessed coefficient matrix. Else use the maximum.
Default is \code{FALSE}}

\item{n_nodes}{Positive integer. The index of the last column in data
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in data, corresponding to no additional covariates}

\item{n_cores}{Positive integer. The number of cores to spread the job across using
\code{\link[parallel]{makePSOCKcluster}}. Default is 1 (no parallelisation)}

\item{sample_seed}{Numeric. This seed will be used as the basis
for dividing data into folds. Default is a random seed
between 1 and 100000}

\item{n_folds}{Positive integer. The number of folds for cross-validation. Default is 10}

\item{n_fold_runs}{Positive integer. The number of total training runs to perform at each
l1 regularization parameter. Defaults to \code{n_folds}}

\item{n_covariates}{Positive integer. The number of covariates in \code{data},
before cross-multiplication}

\item{family}{The response type. Responses can be quantitative continuous (\code{family = "gaussian"}),
non-negative counts (\code{family = "poisson"}) or binomial 1s and 0s (\code{family = "binomial"}). At present,
only \code{family = "binomial"} is supported for this function}
}
\value{
A \code{list} of 11 objects:
\itemize{
   \item \code{mean_pos_pred}: Numeric value of average positive predictive value
   \item \code{mean_neg_pred}: Numeric value of average negative predictive value
   \item \code{mean_tot_pred}: Numeric value of average total rate of correct predictions
   \item \code{mean_sensitivity}: Numeric value of average sensitivity
   \item \code{mean_specificity}: Numeric value of average specificity
   \item \code{pos_pred}: Vector of positive predictive values
   \item \code{neg_pred}: Vector of negative predictive values
   \item \code{tot_pred}: Vector of rate of correct predictions
   \item \code{sensitivity}: Vector of sensitivity values
   \item \code{specificity}: Vector of specificity values
   \item \code{lambda1}: Vector of lambda l1 regularization values
   }
}
\description{
This function runs \code{\link{MRFcov}} models across a specified
range of l1−regularization values, using x-fold cross validation
to assess model predictive performance at each l1 value.
}
\details{
\code{MRFcov} models are run across the specified sequence of \code{lambda1} values.
Cross validation is used to test model predictive capacity at each \code{lambda1}.
For each model, the observed presence-absence values of nodes in a test set of
\code{data} observations is predicted using outputs of an \code{MRFcov} model that is fit to
the remaining observations (training data) using \code{\link{cv_MRF}}.
Test and training \code{data} subsets are created using \code{\link[caret]{createFolds}}.
}
\examples{
\dontrun{data("Bird.parasites")
cv_model <- cv_MRF(data = Bird.parasites, min_lambda1 = 0.5,
                   max_lambda1 = 2, by_lambda1 = 0.5,
                   n_nodes = 4, n_cores = 3)}
}
\seealso{
\code{\link{MRFcov}}, \code{\link{predict_MRF}},
\code{\link{cv_MRF_diag}}, \code{\link[penalized]{penalized}}
}
