% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv_MRF_diag.R
\name{cv_MRF_diag}
\alias{cv_MRF_diag}
\alias{cv_MRF_diag_rep}
\title{MRF cross validation and assessment of predictive performance}
\usage{
cv_MRF_diag(data, min_lambda1, max_lambda1, by_lambda1, symmetrise, n_nodes,
  n_cores, sample_seed, n_folds, n_fold_runs, n_covariates, compare_null,
  family, plot = TRUE, fixed_lambda = FALSE, cached_model,
  cached_predictions)

cv_MRF_diag_rep(data, symmetrise, n_nodes, n_cores, sample_seed, n_folds,
  n_fold_runs, n_covariates, compare_null, family, plot = TRUE)
}
\arguments{
\item{data}{Dataframe. The input data where the \code{n_nodes}
left-most variables are variables that are to be represented by nodes in the graph.
Note that \code{NA}'s are allowed for covariates. If present, these missing values
will be imputed from the distribution \code{rnorm(mean = 0, sd = 1)}, which assumes that
all covariates are scaled and centred (i.e. by using the function
\code{\link[base]{scale}} or similar)}

\item{min_lambda1}{Positive numeric. The lowest l1−regularization value to be tested}

\item{max_lambda1}{Positive numeric. The highest l1−regularization value to be tested}

\item{by_lambda1}{Positive numeric. The increment of the l1 test_data sequence. The test sequence is generated by calling
\code{lamda1_seq = seq(min_lambda1, max_lambda1, by_lambda1)}}

\item{symmetrise}{The method to use for symmetrising corresponding parameter estimates
(which are taken from separate regressions). Options are \code{min} (take the coefficient with the
smallest absolute value), \code{max} (take the coefficient with the largest absolute value)
or \code{mean} (take the mean of the two coefficients). Default is \code{mean}}

\item{n_nodes}{Positive integer. The index of the last column in \code{data}
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in \code{data}, corresponding to no additional covariates}

\item{n_cores}{Positive integer. The number of cores to spread the job across using
\code{\link[parallel]{makePSOCKcluster}}. Default is 1 (no parallelisation)}

\item{sample_seed}{Numeric. This seed will be used as the basis
for dividing data into folds. Default is a random seed
between 1 and 100000}

\item{n_folds}{Integer. The number of folds for cross-validation. Default is 10}

\item{n_fold_runs}{Integer. The number of total training runs to perform at each
l1 regularization parameter. Defaults to \code{n_folds}}

\item{n_covariates}{Positive integer. The number of covariates in \code{data}, before cross-multiplication}

\item{compare_null}{Logical. If \code{TRUE}, null models will also be run and plotted to
assess the influence of including covariates on model predictive performance.
Default is \code{FALSE}}

\item{family}{The response type. Responses can be quantitative continuous (\code{family = "gaussian"}),
non-negative counts (\code{family = "poisson"}) or binomial 1s and 0s (\code{family = "binomial"}).}

\item{plot}{Logical. If \code{TRUE}, \code{ggplot2} objects are returned. If \code{FALSE},
the prediction metrics are returned as a matrix. Default is \code{TRUE}}

\item{fixed_lambda}{Logical determining whether a model should be run using the same l1 regularization
for each individual node. The default value, \code{FALSE}, allows node-specific regressions
to be optimized using the cross-validation procedure in \code{\link[glmnet]{cv.glmnet}} to
find the \code{lambda1} value that minimises mean cross-validated error}

\item{cached_model}{Used by function \code{\link{cv_MRF_diag_rep}} to store an optimised model and prevent
unneccessary replication of node-optimised model fitting}

\item{cached_predictions}{Used by function \code{\link{cv_MRF_diag_rep}} to store predictions from
optimised models and prevent unneccessary replication}
}
\value{
If \code{plot = TRUE}, a \code{ggplot2} object is returned. This will be
either a plot of  relationships between l1−regularization values and predictive metrics
(if \code{fixed_lambda = FALSE}) or boxplots of predictive metrics across test sets using the
optimised model (see \code{\link[glmnet]{cv.glmnet}} for further details of \code{lambda1}
optimisation). If \code{plot = FALSE}, a matrix of prediction metrics is returned.
}
\description{
\code{cv_MRF_diag} runs cross validation of \code{\link{MRFcov}} models across a specified
range of l1−regularization values.

\code{cv_MRF_diag_rep} fits a single node-optimised model (i.e. \code{fixed_lambda = FALSE})
and test's this model's predictive performance across multiple test subsets of the \code{data}.
\cr
\cr
Both functions assess model predictive performance and produce
either diagnostic plots or matrices of predictive metrics.
}
\details{
If \code{fixed_lambda = TRUE}, \code{MRFcov} models are run across the specified
sequence of \code{lambda1} values and cross validation is used to test model
predictive capacity at each \code{lambda1}.
For the fitted models, the observed outcome values of nodes in a test set of
\code{data} observations are predicted using outputs of an \code{MRFcov} model that is fit to
the remaining observations (training data). If \code{fixed_lambda = FALSE} (the default), a single
node-optimised model is fitted using \code{\link[glmnet]{cv.glmnet}},
and this model is used to predict \code{data} test subsets.
Test and training \code{data} subsets are created using \code{\link[caret]{createFolds}}.
\cr
\cr
To account for uncertainty in parameter estimates and in random fold generation, it is recommended
to perform cross-validation multiple times (by controlling the \code{n_fold_runs} argument) using either
\code{cv_MRF_diag} (if \code{fixed_lambda = TRUE}) or \code{cv_MRF_diag_rep} (if \code{fixed_lambda = FALSE}).
The former is useful for iteratively fitting models to different training subsets using a specified
sequence of \code{lambda1} values (and forcing every node-wise regression to use the same
\code{lambda1} value in each iteration), while
the latter is useful for optimising a single model (using \code{\link[glmnet]{cv.glmnet}}) and testing
this model's predictive performance across many test subsets
}
\examples{
\dontrun{
data("Bird.parasites")
# Generate boxplots of model predictive metrics
cv_MRF_diag(data = Bird.parasites, n_nodes = 4,
           n_cores = 3, family = 'binomial')

# Generate boxplots comparing the CRF to an MRF model (no covariates)
cv_MRF_diag(data = Bird.parasites, n_nodes = 4,
           n_cores = 3, family = 'binomial',
           compare_null = TRUE)

# Replicate 10-fold cross-validation 100 times
cv.preds <- cv_MRF_diag_rep(data = Bird.parasites, n_nodes = 4,
                           n_cores = 3, family = 'binomial',
                           compare_null = TRUE,
                           plot = FALSE, n_fold_runs = 100)

# Plot model sensitivity and \% true predictions
library(ggplot2)
gridExtra::grid.arrange(
 ggplot(data = cv.preds, aes(y = mean_sensitivity, x = model)) +
       geom_boxplot() + theme(axis.text.x = ggplot2::element_blank()) +
       labs(x = ''),
 ggplot(data = cv.preds, aes(y = mean_tot_pred, x = model)) +
       geom_boxplot(),
       ncol = 1,
 heights = c(1, 1))
}

}
\seealso{
\code{\link{MRFcov}},
\code{\link{predict_MRF}},
\code{\link[penalized]{penalized}},
\code{\link[glmnet]{cv.glmnet}}
}
