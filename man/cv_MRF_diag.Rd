% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv_MRF_diag.R
\name{cv_MRF_diag}
\alias{cv_MRF_diag}
\title{MRF cross validation plots to optimise regularization parameters}
\usage{
cv_MRF_diag(data, min_lambda1, max_lambda1, by_lambda1, separate_min, n_nodes,
  lambda2, n_cores, sample_seed, n_folds, n_fold_runs, n_covariates,
  compare_null)
}
\arguments{
\item{data}{Dataframe. The input data where the \code{n_nodes}
left-most variables are binary occurrences to be represented by nodes in the graph.
Note that \code{NA}'s are allowed for covariates. If present, these missing values
will be imputed from the distribution \code{rnorm(mean = 0, sd = 1)}, which assumes that
all covariates are scaled and centred (i.e. by using the function
\code{\link[base]{scale}} or similar)}

\item{min_lambda1}{Positive numeric. The lowest l1−regularization value to be tested}

\item{max_lambda1}{Positive numeric. The highest l1−regularization value to be tested}

\item{by_lambda1}{Positive numeric. The increment of the l1 test_data sequence. The test sequence is generated by calling
\code{lamda1_seq = seq(min_lambda1, max_lambda1, by_lambda1)}}

\item{separate_min}{Logical. If \code{TRUE}, interaction coefficients will use the minimum absolute value of
the corresponding parameter estimates, which are taken from separate logistic regressions,
in the symmetric postprocessed coefficient matrix. Else use the maximum.
Default is \code{FALSE}}

\item{n_nodes}{Positive integer. The index of the last column in \code{data}
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in \code{data}, corresponding to no additional covariates}

\item{lambda2}{Numeric (>= 0). Value for l2−regularization, where larger values lead
to stronger shrinking of coefficient magnitudes. Default is 0, but larger values
may be necessary for large or particularly sparse datasets}

\item{n_cores}{Positive integer. The number of cores to spread the job across using
\code{\link[parallel]{makePSOCKcluster}}. Default is 1 (no parallelisation)}

\item{sample_seed}{Numeric. This seed will be used as the basis
for dividing data into folds. Default is a random seed
between 1 and 100000}

\item{n_folds}{Integer. The number of folds for cross-validation. Default is 10}

\item{n_fold_runs}{Integer. The number of total training runs to perform at each
l1 regularization parameter. Defaults to \code{n_folds}}

\item{n_covariates}{Positive integer. The number of covariates in \code{data}, before cross-multiplication}

\item{compare_null}{Logical. If \code{TRUE}, null models will also be run and plotted to
assess the influence of including covariates on model predictive performance.
Default is \code{FALSE}}
}
\value{
A \code{ggplot2} object plotting LOESS regressions of
relationships between l1−regularization values and predictive metrics
}
\description{
This function runs cross validation of \code{\link{MRFcov}} models across a specified
range of l1−regularization values and produces simple diagnostic plots
to assess model predictive performance at each l1 value.
}
\details{
\code{MRFcov} models are run across the specified sequence of \code{lambda1} values.
Cross validation is used to test model predictive capacity at each \code{lambda1}.
For each model, the observed presence-absence values of nodes in a test set of
\code{data} observations is predicted using outputs of an \code{MRFcov} model that is fit to
the remaining observations (training data) using \code{\link{cv_MRF}}.
Test and training \code{data} subsets are created using \code{\link[caret]{createFolds}}.
Plots showing LOESS regressions of prediction metrics vs \code{lambda1} are returned
}
\examples{
\dontrun{
data("Bird.parasites")
cv_MRF_diag(data = Bird.parasites, min_lambda1 = 0.4,
           max_lambda1 = 2, by_lambda1 = 0.1,
           n_nodes = 4, n_cores = 3)}
}
\seealso{
\code{\link{MRFcov}},\code{\link{predict_MRF}},
\code{\link{cv_MRF}},
\code{\link[penalized]{penalized}}
}
